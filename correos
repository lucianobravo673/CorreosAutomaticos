/****************** 
 *      Primero clearTodaySlots 
 *      Segundo nukeMyTriggers 
 *      Tercero setupOnce
 *      Cuarto runScheduleNow
        Y LISTO
******************/


/****************** CONFIG ******************/
const SHEET_NAME = "ESSSTA";
const SPREADSHEET_ID = "1uqV1DbPxwJ9IYN0NXrh4zlwJPnUWYD41O6eoq_lX5Qw"; // OJO: que sea EXACTO el de la URL

const HEADER_ROWS = 0;

const EMAIL_COL = 1;   // A
const SLOT_STATUS_COL = { 1: 2, 2: 4, 3: 6 };  // B, D, F
const SLOT_SENTAT_COL = { 1: 3, 2: 5, 3: 7 };  // C, E, G

const WINDOWS = [
  { start: "17:05", end: "17:10", handler: "sendSlot1" },
  { start: "17:15", end: "17:20", handler: "sendSlot2" },
  { start: "17:25", end: "17:30", handler: "sendSlot3" },
];

const EMAIL_SUBJECT = "ÚLTIMAS PRUEBAS...";
const EMAIL_BODY_TEXT =`PRUEBAS FINALES PARA EMPEZAR A ENVIAR MASIVAMENTE...`;

const EMAIL_BODY_HTML =
`<p>Hola, ¿cómo estás?</p>
<p>Te escribo para que me agarres bien la gaver zurdito<br>
<!-- C A M B I A R -->
Adjunto pdf para que puedan evaluarlo.</p>
<p>Muchas gracias por tu tiempo.<br>
Saludos,<br>
Luciano</p>`;

/****************** HELPERS ******************/
function getSpreadsheet_() {
  return SpreadsheetApp.getActiveSpreadsheet() || SpreadsheetApp.openById(SPREADSHEET_ID);
}

function isValidEmail_(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

/**
 * Devuelve true si "ahora" está dentro de la ventana start-end del día actual.
 * (blindaje: si se ejecuta manual o por un trigger viejo, NO envía fuera de horario)
 */
function isNowInWindow_(startHHMM, endHHMM) {
  const now = new Date();
  const [sh, sm] = startHHMM.split(":").map(Number);
  const [eh, em] = endHHMM.split(":").map(Number);

  const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), sh, sm, 0, 0);
  const end   = new Date(now.getFullYear(), now.getMonth(), now.getDate(), eh, em, 0, 0);

  return now >= start && now <= end;
}

/****************** SETUP ******************/
function setupOnce() {
  const cvFileId = "1CRP-G6BKHW4JA1uOvqRBJKtQS96BKQvm";
  PropertiesService.getScriptProperties().setProperty("CV_FILE_ID", cvFileId);

  ensureDailySchedulerTrigger_();
  Logger.log("Listo: CV_FILE_ID guardado y trigger diario creado.");
}

function ensureDailySchedulerTrigger_() {
  const triggers = ScriptApp.getProjectTriggers();
  const exists = triggers.some(t => t.getHandlerFunction() === "scheduleToday");
  if (!exists) {
    const now = new Date();
    const first = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 5, 0);
    ScriptApp.newTrigger("scheduleToday").timeBased().at(first).create();
  }
}

/****************** SCHEDULING ******************/
function scheduleToday() {
  clearSlotTriggers_();

  const tz = Session.getScriptTimeZone();

  WINDOWS.forEach(w => {
    const runAt = randomDateTimeInWindow_(w.start, w.end);
    ScriptApp.newTrigger(w.handler).timeBased().at(runAt).create();

    // Log de auditoría: cuándo quedó programado cada slot
    Logger.log(`${w.handler} programado para ${Utilities.formatDate(runAt, tz, "yyyy-MM-dd HH:mm:ss")} (ventana ${w.start}-${w.end})`);
  });

  Logger.log("Triggers del día creados.");
  rescheduleScheduleTodayForTomorrow_();
}

function rescheduleScheduleTodayForTomorrow_() {
  ScriptApp.getProjectTriggers()
    .filter(t => t.getHandlerFunction() === "scheduleToday")
    .forEach(t => ScriptApp.deleteTrigger(t));

  const now = new Date();
  const next = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 5, 0);
  ScriptApp.newTrigger("scheduleToday").timeBased().at(next).create();
}

function clearSlotTriggers_() {
  const handlers = new Set(WINDOWS.map(w => w.handler));
  ScriptApp.getProjectTriggers()
    .filter(t => handlers.has(t.getHandlerFunction()))
    .forEach(t => ScriptApp.deleteTrigger(t));
}

/****************** CORE ******************/
function sendSlot1() { sendAllForSlot_(1); }
function sendSlot2() { sendAllForSlot_(2); }
function sendSlot3() { sendAllForSlot_(3); }

function sendAllForSlot_(slotNumber) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    // Blindaje: no envía si está fuera de su ventana (evita manual/trigger viejo)
    const w = WINDOWS[slotNumber - 1];
    if (!w) throw new Error(`Slot inválido: ${slotNumber}`);
    if (!isNowInWindow_(w.start, w.end)) {
      Logger.log(`Slot ${slotNumber}: fuera de ventana (${w.start}-${w.end}). No envío.`);
      return;
    }

    const ss = getSpreadsheet_();
    const sheet = ss.getSheetByName(SHEET_NAME);
    if (!sheet) throw new Error(`No existe la hoja: ${SHEET_NAME}`);

    const props = PropertiesService.getScriptProperties();
    const cvId = props.getProperty("CV_FILE_ID");
    if (!cvId) throw new Error("No está configurado CV_FILE_ID. Ejecutá setupOnce().");
    const cvBlob = DriveApp.getFileById(cvId).getBlob();

    const tz = Session.getScriptTimeZone();
    const todayKey = Utilities.formatDate(new Date(), tz, "yyyyMMdd");

    const lastRow = sheet.getLastRow();
    if (lastRow < 1) return;

    const statusCol = SLOT_STATUS_COL[slotNumber];
    const sentAtCol = SLOT_SENTAT_COL[slotNumber];

    const numCols = Math.max(EMAIL_COL, statusCol, sentAtCol);
    const values = sheet.getRange(1, 1, lastRow, numCols).getValues();

    let sentCount = 0;

    for (let i = 0; i < values.length; i++) {
      const row = i + 1;
      const email = (values[i][EMAIL_COL - 1] || "").toString().trim();
      if (!email || !isValidEmail_(email)) continue;

      const sentAt = values[i][sentAtCol - 1]; // Date o vacío
      const alreadySentToday = isSentToday_(sentAt, tz, todayKey);
      if (alreadySentToday) continue;

      GmailApp.sendEmail(email, EMAIL_SUBJECT, EMAIL_BODY_TEXT, {
        htmlBody: EMAIL_BODY_HTML,
        attachments: [cvBlob],
        name: "Luciano"
      });

      sheet.getRange(row, statusCol).setValue("SENT");

      // Guarda fecha+hora (y formatea para que se vea con hora)
      sheet.getRange(row, sentAtCol)
        .setValue(new Date())
        .setNumberFormat("dd/mm/yyyy HH:mm:ss");

      sentCount++;
    }

    Logger.log(`Slot ${slotNumber}: enviados ${sentCount} correos.`);
  } finally {
    lock.releaseLock();
  }
}

function isSentToday_(sentAtValue, tz, todayKey) {
  if (!sentAtValue) return false;
  if (!(sentAtValue instanceof Date)) return false;
  const key = Utilities.formatDate(sentAtValue, tz, "yyyyMMdd");
  return key === todayKey;
}

/****************** TIME WINDOW ******************/
function randomDateTimeInWindow_(startHHMM, endHHMM) {
  const now = new Date();

  const [sh, sm] = startHHMM.split(":").map(Number);
  const [eh, em] = endHHMM.split(":").map(Number);

  const base = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
  let start = new Date(base); start.setHours(sh, sm, 0, 0);
  let end   = new Date(base); end.setHours(eh, em, 0, 0);

  if (end <= start) throw new Error(`Franja inválida: ${startHHMM} - ${endHHMM}`);

  // Si ya pasó la franja, usar mañana
  if (now >= end) {
    start.setDate(start.getDate() + 1);
    end.setDate(end.getDate() + 1);
  }

  // Si estamos dentro, mínimo = ahora + 1 min (evita agendar en el pasado)
  const minStart = (now > start && now < end) ? new Date(now.getTime() + 60 * 1000) : start;
  if (minStart >= end) return randomDateTimeInWindow_(startHHMM, endHHMM);

  const delta = end.getTime() - minStart.getTime();
  return new Date(minStart.getTime() + Math.floor(Math.random() * delta));
}

/****************** UTILS ******************/
function clearTodaySlots() {
  const ss = getSpreadsheet_();
  const sheet = ss.getSheetByName(SHEET_NAME);
  if (!sheet) throw new Error(`No existe la hoja: ${SHEET_NAME}`);

  const lastRow = sheet.getLastRow();
  if (lastRow < 1) return;

  // Limpia B:G (slot1/2/3 status+sentAt)
  sheet.getRange(1, 2, lastRow, 6).clearContent();
}

/**
 * Reset total de triggers (uso manual cuando querés “empezar de cero”).
 * OJO: borra TODOS los triggers del proyecto.
 */
function nukeMyTriggers() {
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
}

function runScheduleNow() { scheduleToday(); }

/**
 * Test controlado (sin random): dispara slot1/2/3 en +1, +3, +5 minutos.
 * NOTA: este test ignora las ventanas, PERO el guard clause evita envíos fuera de ventana.
 * Si querés que el test sí envíe, poné ventanas que incluyan el horario actual o comentá el guard clause temporalmente.
 */
/*function testNow3Slots() {
  clearSlotTriggers_();

  const now = new Date();
  ScriptApp.newTrigger("sendSlot1").timeBased().at(new Date(now.getTime() + 1 * 60 * 1000)).create();
  ScriptApp.newTrigger("sendSlot2").timeBased().at(new Date(now.getTime() + 3 * 60 * 1000)).create();
  ScriptApp.newTrigger("sendSlot3").timeBased().at(new Date(now.getTime() + 5 * 60 * 1000)).create();

  Logger.log("Test creado: Slot1 +1m, Slot2 +3m, Slot3 +5m.");
}*/
